# Program Execution
In general, p2llvm code will execute in hubex mode, since all code is stored in the hub. Some functions (specifically the propeller runtime library functions), can be placed into cog RAM and be executed from there. Currently, only libcalls generated by the compiler (for LLVM instructions that don't have matching Propeller instructions of simple instruction groups) can be placed into cog RAM. Anything else won't relocate correctly, so function calls will jump to their hub RAM locations instead of the proper cog RAM locations.

Execution is performed similar to a classic processor with a register file and separate memory for data. This layout was described in *Memory Layout*. A stack pointer keeps track of a stack in memory that is used for local variables.

## Stack Pointer
`ptra` is used as the stack pointer and its value gets set up in the cog startup function, `_start()`. In general, the start of a function will allocate the stack space it needs by adding to `ptra`, with the stack growing **up**. There are 2 places where `ptra` gets adjusted automatically: via a function call, which will push PC and the status word to the stack and increment `ptra`, and when functions save registers to the stack in the prologue/restore them in the epilogue. This is described in detail in *Calling Convention* below. Generally, `ptra` always points to first empty stack slot.

## Branching
Branches are always executed using the `jmp` instruction. Instead of trying to generate a conditional `jmp` instructions for various conditions during compilation, a series of conditional jump instructions are defined as independant instructions. This better aligns with how LLVM represents conditional jumps. The LLVM conditional branch instruction (`brcc`) has four operands: the two values to compare, the condition for a true comparison, and where to jump if the comparision is true. The gets converted into two propeller instructions: `cmp x, x wcz` followed by one of the possible jmp instructions. Instead of treating `jmp` as one instruction with condition codes, it is treated as 16 different instructions, one for each conditional flag (`if_z`, etc). The instruction pattern matcher will then select the appropriate instruction based on the condition operand in `brcc`.

## Calling Convention
Data for functions is paseed in and our via two methods: registers or the stack. Various types of data will prefer one or the other. Any function call follows the following process:
1. The **caller** will allocate space on the stack (in needed), write the arguments to the stack (if needed)
1. The **caller** will call the function using `calla`. This auto-increments `ptra`
1. The **callee** will push any registers it needs to save to the stack using block transfers (described below). This will also auto-increment `ptra`
1. The **callee** will allocate any stack space it needs for it's local variables that won't fit in registers, local arrays, etc.
1. The **callee** will read in any stack-based arguments (if needed).
1. The **callee** executes any code necessary, potentially calling more functions
1. The **callee** will set `r30` and `r31` for return values, (if any)
1. The **callee** will pop any registers it saved using block transfers
1. The **callee** will return using `reta`. This will auto-decrement `ptra` and restore PC and the status word to their values before the call.
1. The **caller** will de-allocate the stack allocated before the call.

### Function Arguments
`r0` through `r3` are used to pass single values into functions. This was chosen fairly arbitrarily and if there is a performance boost from increasing to more registers, that can be very easily done. 8 and 16 bit values are promoted to 32 bits. (Aside: I don't know how 64 bit values are handled. They'll either be split into two registers, or they will be passed via an 8-byte stack slot).

Structs/ByVal are passed via the stack. (Aside: I haven't yet found the distinction, but I often see the byval will be copied to the stack, and a pointer will be passed via registers and that pointer will be used to operate on the byval).

Variable argument function argument lists are passed exclively via the stack (even if they are all single values). They are stored in descending order by the caller. This allows the callee to continue to offset downwards from the top of its incoming argument frame until the function logic determines all arguments have been read out. This is necessary since the callee doesn't know how far to offset its stack pointer, since it has no knowledge of how many arguments were passed.

### Return Values
Values are generally returned via `r31`. `r30` is also reserved for return values if 64-bits are to be returned, instead of using the stack. Structs/ByVals should use the stack, though like above, it is often that the caller will allocate stack space for the result and pass a pointer for the callee to store the result into.

### Callee Saved Registers
LLVM's internals will determine which registers need to be saved in the prologue/epilogue and where. Then LLVM calls Target backend code to actually generate the instructions to save these registers. p2llvm's implementation of this uses fast block transfers via `setq` and `rd/wrlong` to `ptra`. This will also auto-increment `ptra`. It's important to note that each continuous block of registers will be written separately, so if the registers to save are `r0`, `r1`, `r2`, and `r4`, then the result to push these to the stack will be

```
setq #2
wrlong r0, #351 // 351 is the special immediate for writing to PTRA with post-increment
wrlong r4, #351
```

This means that if the registers are highly discontinuous, we won't take advantage of block transfers and just end up doing individual writes. (Aside: eventually I'll update the parser to recognize special `ptra` operations).

Restoring CSRs does the exact same thing, just in reverse using `rdlong`.

## Cogex and Hubex Modes
(This section might be moved to its own doc)

By default, code executs in Hubex mode (PC = 0x400 or greater). This is slower, but a lot more flexible for code space. However, several builtin functions are stored in cog LUT RAM, and are re-loaded into each new cog that gets started as a "standard" cog. Cogs can also be started with arbitrary data to begin executing. This can be a function compiled by LLVM, an externally linked binary, or binary blob compiled in with the program. For the first option, the function should be marked with the `cogtext` attribute. (Side note: this doesn't actually do anything right now, but the attribute is made available for future use)

Currently, hub functions cannot call `cogtext` functions, and vice verse. They operate in relatively separate spaces and should be treated as separate programs that have access to some shared memory. However, this should eventually be relaxed as features are expanded, as there's nothing fundamentally incorrect about calling one from the other. (What this means in practice is that the cog startup code should be flexible to accept different types of operating modes, depending on the user's requirements).

### Caching `cogtext` functions

We want some way to cache functions in the cog so that very fast loops can branch into the cog RAM and execute there (where a jump is 4 cycles instead of up to 30). Or, if a hub function wants to use the streamer/FIFO functionality, which is unavailable in hub mode, that code must live in a cog function. So, a function should be marked as cogtext. Such a function should get placed next to the startup code, so that it automatically gets loaded.

The problems with this method currently are:
1) we have no way of knowing what the address of this function will be at compile time, and at link time it's probably hard to figure out. Maybe there's a way to find addresses of other symbols in the linker but not sure if it'll work. 
2) This won't work for native cogs, which will require the cogtext functions to be placed not after the startup code but after the native function's code. 

To solve 1, a fixup should work, similar to how RT libcalls are implemented, but will be just as fragile. Solving this is the same as solving the RT lib problem: we need ld to know where the first rtlib function is located and adjust fixups relative to there, rather than a fixed address. 

To solve 2, we could have the linker somehow know the place a function (or a copy of a function, since it could be reused by multiple cogs) after a "cogmain" function that references it. This seems hard. 

Another way would be have the linker script generate a table in early hub space (which is currently reserved for stuff like this) that maps functions to their sizes, and then have cogs dynamically load this "function cache". However, this also probably requires some amount of linker work as well and is also likely not trivial, or would require the application to list all the functions it wants to load

A third possible option is to do this propgcc style. This could be either compile with an -mcog flag, which might be too restrictive as it would mean all functions are now cahced, or try to set it up such that all functions that are `cogtext` in the same translation unit as a `cogmain` function get lumped together with a new symbol for that main function and the text functions being stuck after it. This is not as flexible as functions are not reusable and therefore can't be placed in libraries. We also will need a way for the top level link to make sure those functions stay stuck together. I think the linker will keep it that way just be how it works, but I don't think that's guaranteed, so it's a fragile way to do it.

#### Option 3

Consider the following example (not complete c++, just for demo purposes)

```cpp
// native_code.h

class Driver {
public:
    void fast_func() __attribute__((section("cog"), cogtext)) {
        ... 
    }

    void cog_main __attribute__((section("cog"), cogmain)) {
        INIT_RTLIB;
        fast_func();
        other_func();
    }

    void other_func();
}

// native_code.cpp

void Driver::other_func() {
    ...
}

```

The required memory organization of the final app is something like: 

```
section text: 
    other_func

section native_code_text:
    cog_main
    fast_func

```

We could generate a symbol to point to the start of `native_code_text` to be more like propgcc for compatibility, should be easy with the linker script, but not required as we can just pass a pointer to `cog_main`

During compilation, symbols will be generated for `fast_func`, `cog_main`, and `other_func`. There will be two sections, cog, and other_func (because we compile with function sections)
