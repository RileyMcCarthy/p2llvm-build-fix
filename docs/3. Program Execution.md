# Program Execution
In general, p2llvm code will execute in hubex mode, since all code is stored in the hub. Some functions (specifically the propeller runtime library functions), can be placed into cog RAM and be executed from there. Currently, only libcalls generated by the compiler (for LLVM instructions that don't have matching Propeller instructions of simple instruction groups) can be placed into cog RAM. Anything else won't relocate correctly, so function calls will jump to their hub RAM locations instead of the proper cog RAM locations. 

Execution is performed similar to a classic processor with a register file and separate memory for data. This layout was described in *Memory Layout*. A stack pointer keeps track of a stack in memory that is used for local variables. 

## Stack Pointer
`ptra` is used as the stack pointer and its value gets set up in the cog startup function, `_start()`. In general, the start of a function will allocate the stack space it needs by adding to `ptra`, with the stack growing **up**. There are 2 places where `ptra` gets adjusted automatically: via a function call, which will push PC and the status word to the stack and increment `ptra`, and when functions save registers to the stack in the prologue/restore them in the epilogue. This is described in detail in *Calling Convention* below. Generally, `ptra` always points to first empty stack slot.

## Branching
Branches are always executed using the `jmp` instruction. Instead of trying to generate a conditional `jmp` instructions for various conditions during compilation, a series of conditional jump instructions are defined as independant instructions. This better aligns with how LLVM represents conditional jumps. The LLVM conditional branch instruction (`brcc`) has four operands: the two values to compare, the condition for a true comparison, and where to jump if the comparision is true. The gets converted into two propeller instructions: `cmp x, x wcz` followed by one of the possible jmp instructions. Instead of treating `jmp` as one instruction with condition codes, it is treated as 16 different instructions, one for each conditional flag (`if_z`, etc). The instruction pattern matcher will then select the appropriate instruction based on the condition operand in `brcc`. 

## Calling Convention
Data for functions is paseed in and our via two methods: registers or the stack. Various types of data will prefer one or the other. Any function call follows the following process:
1. The **caller** will allocate space on the stack (in needed), write the arguments to the stack (if needed)
1. The **caller** will call the function using `calla`. This auto-increments `ptra` 
1. The **callee** will push any registers it needs to save to the stack using block transfers (described below). This will also auto-increment `ptra`
1. The **callee** will allocate any stack space it needs for it's local variables that won't fit in registers, local arrays, etc. 
1. The **callee** will read in any stack-based arguments (if needed). 
1. The **callee** executes any code necessary, potentially calling more functions
1. The **callee** will set `r30` and `r31` for return values, (if any)
1. The **callee** will pop any registers it saved using block transfers
1. The **callee** will return using `reta`. This will auto-decrement `ptra` and restore PC and the status word to their values before the call. 
1. The **caller** will de-allocate the stack allocated before the call.

### Function Arguments
`r0` through `r3` are used to pass single values into functions. This was chosen fairly arbitrarily and if there is a performance boost from increasing to more registers, that can be very easily done. 8 and 16 bit values are promoted to 32 bits. (Aside: I don't know how 64 bit values are handled. They'll either be split into two registers, or they will be passed via an 8-byte stack slot). 

Structs/ByVal are passed via the stack. (Aside: I haven't yet found the distinction, but I often see the byval will be copied to the stack, and a pointer will be passed via registers and that pointer will be used to operate on the byval). 

Variable argument function argument lists are passed exclively via the stack (even if they are all single values). They are stored in descending order by the caller. This allows the callee to continue to offset downwards from the top of its incoming argument frame until the function logic determines all arguments have been read out. This is necessary since the callee doesn't know how far to offset its stack pointer, since it has no knowledge of how many arguments were passed.

### Return Values
Values are generally returned via `r31`. `r30` is also reserved for return values if 64-bits are to be returned, instead of using the stack. Structs/ByVals should use the stack, though like above, it is often that the caller will allocate stack space for the result and pass a pointer for the callee to store the result into. 

### Callee Saved Registers
LLVM's internals will determine which registers need to be saved in the prologue/epilogue and where. Then LLVM calls Target backend code to actually generate the instructions to save these registers. p2llvm's implementation of this uses fast block transfers via `setq` and `rd/wrlong` to `ptra`. This will also auto-increment `ptra`. It's important to note that each continuous block of registers will be written separately, so if the registers to save are `r0`, `r1`, `r2`, and `r4`, then the result to push these to the stack will be

```
setq #2
wrlong r0, #351 // 351 is the special immediate for writing to PTRA with post-increment
wrlong r4, #351
```

This means that if the registers are highly discontinuous, we won't take advantage of block transfers and just end up doing individual writes. (Aside: eventually I'll update the parser to recognize special `ptra` operations). 

Restoring CSRs does the exact same thing, just in reverse using `rdlong`. 
